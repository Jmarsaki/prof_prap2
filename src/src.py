# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gKGJ7QMLhp_XlECSF2lbAXLqVkBJvYAg

Proyecto final de Procesamiento de imagenes de TSCDIA ISPC perteneciente a Julio Mariano Sachi:
"""

from google.colab import drive
drive.mount('/content/drive')

"""##Aplicación para reconocimiento de arañas venenosas"""

# importación de librerías
import pandas as pd
import numpy as np
import os
import tensorflow as tf
import librosa
from sklearn.model_selection import train_test_split
from tensorflow.python.keras.layers import Dense

# Preprocesado y modelado
# ==============================================================================
from sklearn.metrics import accuracy_score
from sklearn.metrics import mean_squared_error


# Configuración warnings
# ==============================================================================
import warnings
warnings.filterwarnings('ignore')

def obtener_etiqueta(image_name):
  # Lógica para obtener la etiqueta de la imagen
  return etiqueta_obtenida

# Recorrer las imágenes en el directorio de entrenamiento
for image_name in os.listdir("/content/drive/MyDrive/arañas_venenosas"):
    if image_name.endswith('.jpg'):
        # Cargar la imagen
        image_path = os.path.join("/content/drive/MyDrive/arañas_venenosas", image_name)
        image = Image.open(image_path)
        image = image.resize((192, 192))  # Redimensionar la imagen si es necesario
        image_array = np.array(image)
        # Normalizar los valores de píxeles (opcional)
        image_array = image_array / 255.0

        # Obtener la etiqueta correspondiente a la imagen
        label = obtener_etiqueta(image_name)  # Reemplaza "obtener_etiqueta" con tu lógica para obtener la etiqueta

        # Agregar la imagen y la etiqueta a las listas
        images.append(image_array)
        labels.append(label)

# Convertir las listas en arrays numpy
images = np.array(images)
labels = np.array(labels)

# Dividir los datos en conjuntos de entrenamiento y validación
train_images, val_images, train_labels, val_labels = train_test_split(images, labels, test_size=0.3, train_size=0.7, random_state=32)

# Definir el modelo

num_classes=1

model = tf.keras.Sequential([
    tf.keras.applications.MobileNetV2(input_shape=(192, 192, 3), include_top=False),
    tf.keras.layers.GlobalAveragePooling2D(),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(num_classes, activation='softmax')
])

# Compilar el modelo
model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])



# Entrenar el modelo
model.fit(train_images, train_labels, validation_data=(val_images, val_labels), epochs=20)

# Guardar el modelo entrenado
model.save('modelo.h5')

loaded_model = tf.keras.models.load_model('modelo.h5')

from PIL import Image

# Cargar y redimensionar la imagen de prueba
test_image = Image.open('/content/drive/MyDrive/arañas_venenosas/arañas_venenosas/100.jpg')
test_image = test_image.resize((192, 192))

# Convertir la imagen a un arreglo numpy
test_array = img_to_array(test_image)
test_array = np.expand_dims(test_array, axis=0)  # Agregar una dimensión adicional para representar el lote (batch)

# Realizar la predicción
predictions = loaded_model.predict(test_array)
predicted_class_index = np.argmax(predictions[0])

# Mapear el índice de clase a la etiqueta correspondiente
labels = ['etiqueta1', 'etiqueta2', 'etiqueta3']  # Reemplaza con tus etiquetas
predicted_label = labels[predicted_class_index]

print('Etiqueta predicha:', predicted_label)